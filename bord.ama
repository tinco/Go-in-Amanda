|| Het Go bord

posStateTp == spelerTp
positionTp == (num, num)
goBordTp == [[posStateTp]]
  
newBord bord_size = (repeat bord_size (repeat bord_size None))

getPosition :: goBordTp -> positionTp -> posStateTp
getPosition bord (x, y)
  = ((bord ! x) ! y)

setPosition :: goBordTp -> posStateTp -> positionTp -> goBordTp
setPosition bord state (x, y)
  = update bord x (update (bord ! x) y state)

neighbours :: goBordTp -> positionTp -> [positionTp]
neighbours bord (x,y)
  = buurposities
  where
    bord_size = #bord
    links  = [(x-1, y)] , if x > 0
           = [] , otherwise
    rechts = [(x+1, y)] , if x < (bord_size - 1)
           = [] , otherwise
    boven  = [(x,y+1)] , if y < (bord_size - 1)
           = [] , otherwise
    onder  = [(x, y-1)] , if y > 0
           = [] , otherwise
    buurposities = links ++ rechts ++ boven ++ onder
    
posLiberties :: goBordTp -> positionTp -> [positionTp]
posLiberties bord position
  = [ p | p <- (neighbours bord position) ; getPosition bord p = None]
    
group :: goBordTp -> positionTp -> [positionTp]
group bord positie
  = h_groep bord [] [positie]
        
|| Geeft de posities voor de stenen. Op het bord. 
getPositions :: goBordTp -> [(positionTp,spelerTp)]      
getPositions bord
  = stenen
  where
    bord_size = #bord
    || Dit is redelijk sexy:
    positions = concat (zipwith (rij->space_x->
                 (zipwith (steen->space_y->
                   ((space_x, space_y), steen)
                  ) rij ( (nat 0 (bord_size -1))) ) || Spiegelen in de y-as
                ) bord (nat 0 (bord_size -1)) )
    stenen = filter ((_,c)-> c ~= None) positions
      
getGroups :: goBordTp -> [([positionTp], spelerTp)]
getGroups bord
  = h_groups bord ([p | (p,c)<-(getPositions bord)]) []
    
h_groups bord [] groups = groups
h_groups bord ((position):positions) groups
  = h_groups bord new_positions new_groups
  where
    new_group = (group bord position)
    kleur = getPosition bord position
    new_groups = (new_group, kleur) : groups
    new_positions = positions -- new_group
        
h_groep :: goBordTp -> [positionTp] -> [positionTp] -> [positionTp]
h_groep bord collected fringe
  = h_groep bord new_collected new_fringe, if new_fringe ~= []
  = new_collected , otherwise
  where
    kleur = getPosition bord (hd fringe)
    new_collected = collected ++ fringe
    new_fringe = (unique 
                  ( filter
                    (x-> getPosition bord x = kleur)  
                    (concat (map (neighbours bord) fringe))
                  )
                 ) -- collected

groupLiberties :: goBordTp -> [positionTp] -> [positionTp]
groupLiberties bord group
  = unique (concat (map (posLiberties bord) group))
      
ex_group = [[Black, Black, Black] ,
            [Black, None,  Black] ,
            [Black, Black, None ] ]
            