|| Statemachine die door de fases van het spel gaat:

|| Main Flow:
|| Begin -> (bevestig) -> Turn *
|| Turn * -> (maakt move) -> Turn **
|| Turn * -> (maakt ongeldige move) **
|| Turn * -> (past (1e pas)) -> Turn **
|| Turn * -> (past (2e pas)) -> Score
|| Turn * -> (resign) -> Eind(**)
|| Score -> (markeer dode groep (groepen over)) -> Score
|| Score -> (markeer dode groep (geen groep over)) -> Eind(*)
|| Eind -> (bevestig) -> Begin

|| Regels: http://en.wikipedia.org/wiki/Rules_of_Go
|| Extra regels:
|| Suicide is verboden
|| Geen 

gameStatesTp ::= Begin | Turn | Score | Eind
gameStateTp == (gameStatesTp, gameTp, [inputevent])

|| Een statemachine die het bovenbeschreven spelverloop modelleert.
gameFSA :: gameStateTp -> gameStateTp
gameFSA (Begin, game, events) = (Turn, newGame, rest)
                              where
                                (newGame, rest) = (executeBegin events)
gameFSA (Turn, game, events) = (newState, newGame, rest)
                             where
                              (newGame, rest) = executeTurn game events
                              {pass=pass, winnaar=winnaar} = newGame
                              newState = Score , if pass = 2
                                       = Eind , if winnaar ~= None
                                       = Turn , otherwise
gameFSA (Score, game, events) = (Eind, newGame, rest)
                              where
                                (newGame, rest) = executeScore game events
gameFSA (Eind, game, events) = (Begin, newGame, rest)
                             where
                                (newGame, rest) = executeEind game events
                  
nextPlayer White = Black
nextPlayer Black = White

|| In deze fase vragen om komi en bord size
executeBegin events = (new_game , events)
                    where
                      new_game = renderGame (newGameState 6.5 19)
         
|| Request een zet.
executeTurn game events
 = (new_game, rest)
 where
   (newGame, rest) = handleTurn game events
   {speler=speler} = newGame
   new_game = renderGame (newGame & {speler=(nextPlayer speler)})

executeScore game events = (game , events)
executeEind game events = (game, events)
  
runGame :: gameStateTp -> [graphics]
runGame (state)
  = graphics ++ (runGame (s,newGame,r)) , if s ~= Eind
  = graphics , otherwise
  where
    (s,newGame,r) = gameFSA (state)
    {graphics=graphics} = newGame