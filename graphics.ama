|| Graphics
posTp == (num, num)

|| Geeft de graphics objecten voor het gegeven bord terug.  
tekenBord :: goBordTp -> [(graphics)]
tekenBord bord = background : goban : lijnen ++ stenen
  where
    bord_size = #bord
    background = GraphRectangle darkgrey ((-1),(-1)) (1,1)
    goban_s = goban_spacing bord_size
    goban = GraphRectangle lightgrey (hd goban_s, hd goban_s) (last goban_s, last goban_s)
    lijnen = map (l->GraphPolyLine black l) (lineCoords bord_size)
    stenen = map (((x, y), k)->GraphDisc (spelerKleur k) x y) (stoneCoords bord)
      
renderBord game
  = new_game
  where
    {bord=bord, graphics=graphics} = game
    new_game = game & {graphics=(graphics++(tekenBord bord))} 
      
renderScore game
  = new_game
    where
      new_game = (renderBord game)
     
renderGame game
  = new_game & 
    {graphics= GraphClear :
              (GraphTitle "Play Go! by Jarmo van Lenthe and Tinco Andringa") :
               graphics} || Clear de graphics voor iedere render.
    where
      new_game = (renderStatusBar (renderBord game))
      {graphics=graphics} = new_game

|| Status, wie is aan beurt, wat zijn de scores, wat is de fase.        
renderStatusBar game
 = game & {graphics = new_graphics}
  where
    {graphics=graphics, bord=bord} = game
    space = game_space (#bord)
    bar_coords = [(-1, 2 - space), (1, 2-space), (1,2), (-1,2), (-1, 2-space)]
    new_graphics = GraphPolygon white bar_coords :
                   GraphPolyLine black bar_coords : graphics

|| Geeft de posities van de lijnen op het bord.
lineCoords :: num -> [[posTp]]
lineCoords n
  = verts ++ horizs
  where    
    spacing = bord_spacing n
    vert_begins = zip (spacing, repeat n (hd spacing))
    vert_ends = zip (spacing, repeat n (last spacing))
    verts = zipwith (toline) vert_begins vert_ends
    horiz_begins = zip (repeat n (hd spacing), spacing)
    horiz_ends = zip (repeat n (last spacing), spacing)
    horizs = zipwith (toline) horiz_begins horiz_ends

|| Geeft de posities voor de stenen. Op het bord. 
stoneCoords :: goBordTp -> [((posTp,posTp),spelerTp)]      
stoneCoords bord
  = stenen
  where
    bord_size = #bord
    spacing = bord_spacing bord_size
    || Dit is redelijk sexy:
    positions = concat (zipwith (rij->space_x->
                 (zipwith (steen->space_y->
                   (discPosition bord_size (space_x, space_y), steen)
                  ) rij (reverse spacing) ) || Spiegelen in de y-as
                ) bord spacing )
    stenen = filter ((_,c)-> c ~= None) positions
    
      
|| Om de punten van het bord is 1 space ruimte voor de stenen
|| en 1 space ruimte voor de rand van het bord
|| Deze functies geven arrays met daarin de verdeling van het bord
|| over de range -1 tot 1 voor gebruik in de graphics functies
game_spacing :: num -> [num]
game_spacing bord_size = (spread (-1) 1 (bord_size+4))
goban_spacing :: num -> [num]
goban_spacing bord_size = sublist (game_spacing bord_size) 1 (bord_size + 2)
bord_spacing :: num -> [num]
bord_spacing bord_size = sublist (goban_spacing bord_size) 1 bord_size
game_space :: num -> num
game_space bord_size = 2 // (bord_size + 3)

|| Maakt van 2 posities een array voor PolyLine
toline :: posTp -> posTp -> [posTp]
toline b e = [b, e]

|| Converteert een spelerkleur naar de corresponderende graphics kleur
spelerKleur :: spelerTp -> num
spelerKleur White = white
spelerKleur Black = black

|| Geeft de positie informatie voor een steen terug gebaseerd
|| op de spacing die het huidige bord gebruikt en de positie.
discPosition :: num -> posTp -> (posTp, posTp)  
discPosition bord_size (x,y) 
  = ((x - stone_radius, y - stone_radius), (x + stone_radius, y + stone_radius))
  where
    stone_radius = stoneRadius bord_size

|| Retourneert de radius van een steen gegeven de bord_size
stoneRadius :: num -> num
stoneRadius bord_size
  = ((game_space bord_size) // 2 ) * (15//16)
      
|| Retourneert de bordpositie voor een graphics positie als die positie op het bord is.
onStone :: goBordTp -> posTp -> maybe posTp
onStone bord (x,y)
  = Just (pos_x, pos_y) , if on_bord x /\ on_bord y
  = Nothing , otherwise
    where
      bord_size = #bord
      spacing = bord_spacing bord_size
      stone_radius  = space // 2
      space = game_space (bord_size)
      closest_space = x->( hd [i | (s,i)<-(zip (spacing,nat 0 (bord_size - 1) )) ; ((s - x) <= stone_radius) /\ ((s - x) >= (-stone_radius))])
      pos_x = (closest_space x)
      pos_y = (bord_size-1 ) - (closest_space y)
      on_bord = x -> between ((hd spacing) - stone_radius) ((last spacing) + stone_radius) x

||============= constants =====================================

black       =  0
darkblue    =  1
darkgreen   =  2
greyblue    =  3
darkred     =  4
purple      =  5
mudgreen    =  6
lightgrey   =  7
darkgrey    =  8
blue        =  9
lightgreen  = 10
lightblue   = 11
red         = 12
lightpurple = 13
yellow      = 14
white       = 15